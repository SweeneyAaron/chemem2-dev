# This file is part of the ChemEM software.
#
# Copyright (c) 2026 - Topf Group & Leibniz Institute for Virology (LIV),
# Hamburg, Germany.
#
# This module was developed by:
#   Aaron Sweeney    <aaron.sweeney AT cssb-hamburg.de>
import numpy as np

from scipy.spatial import distance
from scipy.ndimage import generate_binary_structure, binary_closing
from sklearn.cluster import KMeans
from kneed import KneeLocator

from typing import Iterable, List, Tuple, Optional
Pose = Tuple[float, np.ndarray]


def kmeans_elbow_clustering(X_proc, k_range=range(1, 11), random_state=42):
    """Performs KMeans clustering determining optimal K via KneeLocator."""
    ks, inertias = [], []
    for k in k_range:
        model = KMeans(n_clusters=k, init="k-means++", n_init=10, max_iter=300, random_state=random_state)
        model.fit(X_proc)
        ks.append(k)
        inertias.append(model.inertia_)

    kl = KneeLocator(ks, inertias, curve="convex", direction="decreasing")
    elbow_k = int(kl.elbow) if kl.elbow else 1
    
    final_km = KMeans(n_clusters=elbow_k, n_init=10, random_state=random_state).fit(X_proc)
    return elbow_k, final_km.labels_, inertias

def kmeans_clustering_split(points_coords, points_indices, origin, apix):
    """Splits points using K-Means with Elbow detection."""
    # Elbow method
    ks, inertias = [], []
    k_range = range(1, min(11, len(points_coords)))
    
    for k in k_range:
        km = KMeans(n_clusters=k, init='k-means++', n_init=10).fit(points_coords)
        ks.append(k)
        inertias.append(km.inertia_)
        
    kl = KneeLocator(ks, inertias, curve="convex", direction="decreasing")
    best_k = int(kl.elbow) if kl.elbow else 1
    
    final_km = KMeans(n_clusters=best_k, n_init=10).fit(points_coords)
    labels = final_km.labels_
    
    # Group results
    results = []
    for k in range(best_k):
        mask = labels == k
        subset_indices = points_indices[mask]
        subset_coords = points_coords[mask]
        
        centroid = subset_coords.mean(axis=0)
        radius = np.max(np.linalg.norm(subset_coords - centroid, axis=1))
        
        results.append({
            'indices': subset_indices,
            'centroid': centroid,
            'radius': radius
        })
        
    return results

def get_valid_points_and_adjacency(mask, connectivity=26):
    """Extracts valid indices and adjacency list from boolean mask."""
    nx, ny, nz = mask.shape
    valid_points = np.argwhere(mask) # (N, 3)
    point_map = {tuple(p): i for i, p in enumerate(valid_points)}
    
    adjacency = []
    offsets = [np.array([i, j, k]) for i in (-1,0,1) for j in (-1,0,1) for k in (-1,0,1) if not (i==0 and j==0 and k==0)]
    
    if connectivity == 6:
        offsets = [o for o in offsets if np.sum(np.abs(o)) == 1]
        
    for p in valid_points:
        neighbors = []
        for off in offsets:
            neighbor = tuple(p + off)
            if neighbor in point_map:
                neighbors.append(point_map[neighbor])
        adjacency.append(neighbors)
        
    return valid_points, adjacency

def get_centroid_and_radius(points: np.ndarray):
    """Calculates centroid and bounding radius of a point cloud."""
    pts = np.asarray(points, dtype=np.float64)
    if pts.size == 0:
        return np.zeros(3), 0.0
    centroid = pts.mean(axis=0)
    radius = np.linalg.norm(pts - centroid, axis=1).max()
    return centroid, radius



def compute_circumsphere(vertices):
    A, B, C, D = vertices
    # Setup matrices for solving the circumcenter
    lhs = 2 * np.array([A - D, B - D, C - D])
    rhs = np.array([
        np.dot(A, A) - np.dot(D, D),
        np.dot(B, B) - np.dot(D, D),
        np.dot(C, C) - np.dot(D, D)
    ])
    # Solve for the circumcenter
    circumcenter = np.linalg.solve(lhs, rhs) #+ D
    # Calculate the radius
    #radius = np.linalg.norm(circumcenter - A)
    radius = distance.euclidean(circumcenter, A)
    return circumcenter, radius


def write_xyz(points, filename="points.xyz"):
    """
    Writes a list of points as carbon atoms in an XYZ file format.

    Parameters:
        points (numpy.ndarray): A 2D numpy array of shape (n, 3) where each row is [x, y, z].
        filename (str): Name of the output file. Default is "points.xyz".
    """
    num_atoms = points.shape[0]  # Number of atoms (rows in the array)
    
    with open(filename, "w") as f:
        # Write the number of atoms as the first line (required in XYZ format)
        f.write(f"{num_atoms}\n")
        # Comment line (optional in XYZ format, can be left blank or used for metadata)
        f.write("Generated by write_xyz function\n")
        
        # Write each point as a carbon atom line in the format: "C x y z"
        for point in points:
            x, y, z = point
            f.write(f"Ne {x:.3f} {y:.3f} {z:.3f}\n")

def select_atoms_in_sphere(
    all_coords: np.ndarray,
    all_radii: np.ndarray,
    center: np.ndarray,
    radius: float
) -> (np.ndarray, np.ndarray):
    """
    Selects atoms and their radii within a given spherical region.

    Args:
        all_coords (np.ndarray): The complete array of atom coordinates, shape (N, 3).
        all_radii (np.ndarray): The complete array of atom VDW radii, shape (N,).
        center (np.ndarray): The [x, y, z] coordinate for the center of the selection sphere.
        radius (float): The radius of the selection sphere.

    Returns:
        tuple[np.ndarray, np.ndarray]:
        - filtered_coords (np.ndarray): Coordinates of atoms within the sphere.
        - filtered_radii (np.ndarray): Radii of atoms within the sphere.
    """
    # Calculate the distance of every atom from the center point
    distances = np.linalg.norm(all_coords - center, axis=1)
    
    # Create a boolean mask where True indicates the atom is within the radius
    mask = distances <= radius
    
    # Apply the mask to filter both the coordinates and radii arrays
    filtered_coords = all_coords[mask]
    filtered_radii = all_radii[mask]
    
    return filtered_coords, filtered_radii

def calculate_rmsd(coords1: np.ndarray, coords2: np.ndarray) -> float:
    """RMSD without alignment/superposition; coords must have same shape."""
    if coords1.shape != coords2.shape:
        raise ValueError(f"Shape mismatch: {coords1.shape} vs {coords2.shape}")
    d2 = np.sum((coords1 - coords2) ** 2, axis=1)
    return float(np.sqrt(np.mean(d2)))

def rmsd_cluster(
    sorted_poses: List[Pose],
    rmsd_threshold: float = 2.0,
    n_heavy: Optional[int] = None,
) -> List[Pose]:
    """
    Greedy RMSD clustering (keeps best-first representatives).
    If n_heavy is provided, compares only coords[:n_heavy] but returns full coords.
    """
    def heavy(coords: np.ndarray) -> np.ndarray:
        return coords[:n_heavy] if n_heavy else coords

    diverse: List[Pose] = []
    for score, full_coords in sorted_poses:
        trial = heavy(full_coords)
        for _, kept_full in diverse:
            if calculate_rmsd(trial, heavy(kept_full)) < rmsd_threshold:
                break
        else:
            diverse.append((score, full_coords))
    return diverse



